/**
 * @file node_modules/core/schedule.js
 * @description 중앙 tick 기반 주기 작업 레지스트리
 */


/**
 * @typedef {object} PeriodicTask
 * @property {string} id
 * @property {number} intervalMs
 * @property {number} nextAt
 * @property {(now:number)=>void} handler
 * @property {string} [featureName]
 * @property {string|bigint} [roomId]
 * @property {boolean} [alignToTick]
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "schedule.js";
const { Logger } = require("shared/logger");
const featurePolicy = require("core/featurePolicy");
const bot = BotManager.getCurrentBot();


let _tasks = []; // {id, intervalMs, nextAt, handler, featureName?, roomId?, alignToTick?}




/* =================================== 메인 로직 =================================== */


/**
 * @description 주기 작업 등록
 * @param {object} opt
 * @param {string} [opt.id] 고정 ID, 없으면 자동
 * @param {number} opt.intervalMs
 * @param {(now:number)=>void} opt.handler
 * @param {string} [opt.featureName] 토글 적용 대상 기능명
 * @param {string|bigint} [opt.roomId] 방별 토글 체크용 roomId
 * @param {boolean} [opt.alignToTick=true] true면 등록 시점 기준으로 tick 정렬
 * @returns {string} task id
 */
function registerPeriodic(opt) {
    const now = Date.now();
    const id = opt.id || `t_${now}_${Math.random().toString(36).slice(2, 8)}`;
    const intervalMs = opt.intervalMs;
    const handler = opt.handler;
    const featureName = opt.featureName;
    const roomId = opt.roomId;
    const alignToTick = opt.alignToTick !== false;
  
    /** @type {PeriodicTask} */
    const task = {
        id,
        intervalMs,
        nextAt: alignToTick ? now + intervalMs : now,
        handler,
        featureName,
        roomId,
        alignToTick
    };
    _tasks.push(task);
    return id;
}
/** @description 등록 취소 */
function unregister(id) {
    _tasks = _tasks.filter(t => t.id !== id);
}


/** @description tick 루프에서 호출되는 실행부 */
function tick() {
    const now = Date.now();
    for (let t of _tasks) {
        if (t.nextAt <= now) {
            if (t.featureName && t.roomId) {
                const enabled = featurePolicy.isEnabledForRoom(t.roomId, t.featureName);
                if (!enabled) { t.nextAt = now + t.intervalMs; continue; }
            }
            try { t.handler(now); }
            catch(e) { Logger.e(_SCRIPT_NAME, e); }
            t.nextAt = now + t.intervalMs;
        }
    }
}


/** @description 모든 작업 초기화 */
function clear() {
    _tasks.length = 0;
}


bot.addListener(Event.START_COMPILE, () => { clear(); });


module.exports = { registerPeriodic, unregister, clear, tick };