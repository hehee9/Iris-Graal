/**
 * @file node_modules/core/router.js
 * @description 파싱된 메시지/피드를 기능 모듈로 분배
 */


/**
 * @typedef {object} HandlerMeta
 * @property {Function} handler
 * @property {number} priority
 * @property {string} feature
 */
/**
 * @callback MessageHandler
 * @param {Message} msg
 * @returns {boolean|void} true를 반환하면 이후 핸들러 중단
 */
/**
 * @typedef {object} CommandItem
 * @property {string|string[]} commands // 접두사 제외, 하나 이상
 * @property {string} description
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "router.js";
const { Logger } = require("shared/logger");
const parser = require("adapters/kakao/parser");
const featurePolicy = require("core/featurePolicy");
const hydrator = require("adapters/kakao/hydrator");
const { enqueueText, enqueueMedia, onInboundMessage } = require("infra/queue");
const { CMD_PREFIX, VIEW_MORE, DIVIDE_LINE, REMOVE_ZWS } = require("shared/config");


/** @type {HandlerMeta[]} */
const messageHandlers = [];
/** @type {Map<string, HandlerMeta[]>} */
const feedHandlers = new Map();
/** @type {Record<string, { name: string, items: CommandItem[] }>} */
const _commandIndex = Object.create(null);




/* =================================== 유틸/헬퍼 =================================== */


/**
 * @description 메시지 응답 메서드 바인딩
 * @param {object} msg 파싱된 메시지
 * @returns {Message} 확장된 메시지 객체
 */
function _enrichMessage(msg) {
    return {
        ...msg,
        send: (text) => {
            enqueueText(msg.room.channelId, text);
            return true;
        },
        sendMedia: (media, timeoutMs, fileName) => {
            enqueueMedia(msg.room.channelId, media, timeoutMs, fileName);
            return true;
        }
    };
}

/**
 * @description 피드 응답 메서드 바인딩
 * @param {object} feed 파싱된 피드
 * @returns {Feed} 확장된 피드 객체
 */
function _enrichFeed(feed) {
    const roomId =
        feed?.room?.channelId ||
        feed?.json?.chat_id ||
        feed?.chat_id ||
        feed?.msg?.chat_id;

    return {
        ...feed,
        roomId,
        send: (text) => (roomId ? enqueueText(roomId, text) : false),
        sendMedia: (media, timeoutMs, fileName) =>
            roomId ? enqueueMedia(roomId, media, timeoutMs, fileName) : false
    };
}

/**
 * @description feature.commandList 정규화
 * @param {Array<{command: string|string[], description?: string}>} list
 * @returns {CommandItem[]}
 */
function _normalizeCommandList(list) {
    if (!Array.isArray(list)) return [];
    const out = [];
    for (const it of list) {
        try {
            let cmds = it.command;
            if (typeof cmds === "string") cmds = [cmds];
            if (!Array.isArray(cmds)) continue;

            const commands = cmds
                .map(c => (typeof c === "string" ? c.trim() : ""))
                .filter(c => c.length > 0);

            if (commands.length === 0) continue;

            const description = typeof it.description === "string" ? it.description : "";
            out.push({ commands, description });
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
        }
    }
    return out;
}
/**
 * @description 명령어 목록 문자열 포맷
 * @param {string|bigint} roomId
 * @param {{ feature?: string, heading?: string }} [opt]
 * @returns {string} 출력 문자열
 */
function formatCommandList(roomId, opt) {
    const featureFilter = opt?.feature ? String(opt.feature) : null;
    const heading = opt?.heading ? String(opt.heading) : "사용 가능한 명령어";

    const { totalFeatures, features } = getCommandsForRoom(roomId, featureFilter);

    if (totalFeatures === 0) {
        if (featureFilter) {
            return `${heading}\n\n${DIVIDE_LINE}\n\n해당 방에서 '${featureFilter}' 기능은 비활성화되어 있거나, 명령어가 없습니다.`;
        }
        return `${heading}\n\n${DIVIDE_LINE}\n\n이 방에서 사용할 수 있는 명령어가 없습니다.`;
    }

    let lines = [];
    lines.push(heading + VIEW_MORE);
    lines.push("");
    lines.push(DIVIDE_LINE);
    lines.push("");

    for (const { feature, items } of features) {
        lines.push(`《${feature}》`);
        for (const it of items) {
            const cmds = it.commands.map(c => `〔${CMD_PREFIX}${c}〕`).join(" ");
            if (it.description && it.description.length > 0) {
                lines.push(`⦁ ${cmds}\n   ${it.description}`);
            } else {
                lines.push(`⦁ ${cmds}`);
            }
        }
        lines.push("");
    }

    // 긴 메시지 안전 처리
    return `${lines.join("\n")}`;
}
/**
 * @description 도움말 핸들러
 * @type {MessageHandler}
 */
function _helpMessageHandler(msg) {
    try {
        const text = msg.content || "";
        if (!text.startsWith(CMD_PREFIX)) return;

        const payload = text.slice(CMD_PREFIX.length).trim();
        if (!payload) return;

        const [rawCmd, ...rest] = payload.split(/\s+/);
        const cmd = rawCmd.toLowerCase();

        if (!["명령어", "도움말", "help"].includes(cmd)) return;
        const featureFilter = rest[0] ? rest[0].trim() : null;

        const out = formatCommandList(msg.room.channelId, {
            feature: featureFilter || undefined,
            heading: "【헤\u200b히봇 명령어 목록】"
        });
        msg.send(out);
        return true;
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }
}




/* =================================== 메인 로직 =================================== */


/**
 * @description (내부) 메시지 핸들러 등록
 * @param {MessageHandler} handler
 * @param {number} [priority=100] 높을수록 먼저 실행
 * @param {string} [feature="__core"]
 */
function registerMessage(handler, priority = 100, feature = "__core") {
    messageHandlers.push({ handler, priority, feature });
    messageHandlers.sort((a, b) => b.priority - a.priority);
}
/**
 * @description (내부) 피드 핸들러 등록
 * @param {number|string} feedType
 * @param {Function} handler
 * @param {number} [priority=100] 높을수록 먼저 실행
 * @param {string} [feature="__core"]
 */
function registerFeed(feedType, handler, priority = 100, feature = "__core") {
    const key = String(feedType);
    if (!feedHandlers.has(key)) feedHandlers.set(key, []);
    const arr = feedHandlers.get(key);
    arr.push({ handler, priority, feature });
    arr.sort((a, b) => b.priority - a.priority);
}
/**
 * @description featureName으로 태깅되는 register 래퍼 제공
 * @param {string} featureName
 */
function buildFeatureContext(featureName) {
    return {
        registerMessage: (handler, priority = 100) => registerMessage(handler, priority, featureName),
        registerFeed: (feedType, handler, priority = 100) => registerFeed(feedType, handler, priority, featureName),
    };
}


/** @description 메시지 라우팅 진입점(raw → parse → dispatch) */
function routeMessage(raw) {
    let msg;
    try {
        msg = parser.parseMessage(raw);
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
        return;
    }
  
    try {
        msg.content = String(hydrator.ensureFullContent(raw) || msg.content);
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }

    // 공백 문자 제거
    if (REMOVE_ZWS) msg.content = msg.content.replace(/\u200b|\u200d/g, "");
  
    // queue가 스스로 관찰치 갱신하도록 위임
    try {
        onInboundMessage(msg);
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }

    if (msg?.isMine || msg?.author?.isBanned) return;

    const enrichedMsg = _enrichMessage(msg);

    for (const { handler, feature } of messageHandlers) {
        try {
            if (feature !== "__core") {
                const enabled = featurePolicy.isEnabledForRoom(
                    msg.room.channelId,
                    feature
                );
                if (!enabled) continue;
            }

            const stop = handler(enrichedMsg);
            if (stop === true) break;
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
        }
    }
}
/** @description 피드 라우팅 진입점 */
function routeFeed(feed) {
    const key = String(feed.feedType || "");
    const arr = feedHandlers.get(key) || [];
    const enrichedFeed = _enrichFeed(feed);

    for (const { handler, feature } of arr) {
        try {
            if (feature !== "__core" && enrichedFeed.roomId != null) {
                const enabled = featurePolicy.isEnabledForRoom(enrichedFeed.roomId, feature);
                if (!enabled) continue;
            }

            const stop = handler(enrichedFeed);
            if (stop === true) break;
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
        }
    }
}


/**
 * @description 방에서 사용 가능한 명령어 카탈로그 조회
 * @param {string|bigint} roomId
 * @param {string} [featureFilter] 특정 기능만 필터
 * @returns {{ totalFeatures: number, features: Array<{feature: string, items: CommandItem[]}> }}
 */
function getCommandsForRoom(roomId, featureFilter) {
    const res = [];
    const filter = featureFilter ? String(featureFilter) : null;

    for (const feature of Object.keys(_commandIndex)) {
        if (filter && feature !== filter) continue;

        const enabled = featurePolicy.isEnabledForRoom(roomId, feature);
        if (!enabled) continue;

        const entry = _commandIndex[feature];
        if (!entry || !entry.items || entry.items.length === 0) continue;

        res.push({ feature, items: entry.items });
    }

    return { totalFeatures: res.length, features: res };
}


/** @description 기능 모듈 일괄 등록, featurePolicy 기본값 보장 */
function init() {
    /** @type {{name: string, path: string, defaultEnabled?: boolean}[]} */
    const features = [
        // 기본
        { name: "밴/언밴", path: "features/moderation", defaultEnabled: true,
            commandList: []
        },
        { name: "환영 메시지", path: "features/firstChat", defaultEnabled: true,
            commandList: []
        },
        { name: "입퇴장 감지", path: "features/memberFeed", defaultEnabled: true,
            commandList: []
        },
        /*
        { name: "schedule", path: "features/schedule", defaultEnabled: true,
            commandList: [
                { command: "", description: "" },
                { command: "", description: "" }
            ]
        },
        */
    ];
  
    for (const f of features) {
        try {
            featurePolicy.ensureFeature(f.name, f.defaultEnabled !== false);

            if (f.commandList && Array.isArray(f.commandList)) {
                const normalized = _normalizeCommandList(f.commandList);
                if (normalized.length > 0) {
                    _commandIndex[f.name] = { name: f.name, items: normalized };
                }
            }

            const mod = require(f.path);
            if (mod && typeof mod.register === "function") {
                mod.register(buildFeatureContext(f.name));
            } else {
                Logger.w(_SCRIPT_NAME, `${f.path} 모듈이 없거나 등록할 수 없음`);
            }
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
        }
    }

    registerMessage(_helpMessageHandler, 60, "__core");
}


module.exports = {
    init, registerMessage, registerFeed, routeMessage, routeFeed,
    getCommandsForRoom, formatCommandList
};