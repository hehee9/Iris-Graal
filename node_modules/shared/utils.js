/**
 * @file node_modules/shared/utils.js
 * @description 유용한 기능 모음
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "utils.js";
const { Logger } = require("shared/logger");
const {
    IRIS_QUERY_URL, IRIS_REPLY_URL, IRIS_QUERY_TIMEOUT,
    ADMIN_IDS, CMD_PREFIX
} = require("shared/config");


const Jsoup = Java.type("org.jsoup.Jsoup");
const Method = Java.type("org.jsoup.Connection$Method");
const Runtime = Java.type("java.lang.Runtime");
// const ManagementFactory = Java.type("java.lang.management.ManagementFactory"); // 지원 안 하는 듯 함




/* =================================== 메인 로직 =================================== */


/**
 * @description Iris SQLite 쿼리문 실행
 * @param {string} query 
 * @returns {object|null}
 */
function executeQuery(query) {
    try {
        const response = Jsoup.connect(IRIS_QUERY_URL)
            .header("content-type", "application/json")
            .requestBody(JSON.stringify({ query }))
            .method(Method.POST)
            .ignoreContentType(true)
            .ignoreHttpErrors(true)
            .maxBodySize(0)
            .timeout(IRIS_QUERY_TIMEOUT)
            .execute().body();
        
        const json = JSON.parse(response);
        if (!json.data || json.data.length === 0) return null;
        const result = json.data[0];
        return result;
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
        return null;
    }
}


/**
 * @description Iris를 이용한 응답 전송
 * @param {string|bigint} channelId 
 * @param {string} msg 
 * @returns {boolean} 전송 성공 여부
 */
function irisReply(channelId, msg) {
    try {
        const response = Jsoup.connect(IRIS_REPLY_URL)
            .header("content-type", "application/json")
            .requestBody(JSON.stringify({
                type: "text",
                room: String(channelId),
                data: msg
            }))
            .method(Method.POST)
            .ignoreHttpErrors(true)
            .ignoreContentType(true)
            .execute();
        
        const code = response.statusCode();
        if (code !== 200) return false;

        return true;
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
        return false;
    }
}


/** @description 관리자인지 판단 */
function isAdmin(userId) {
    const id = String(userId);
    return ADMIN_IDS.includes(id);
}
/** @description 관리자인지 판단 */
function isBanned(userId) {
    return require("features/moderation").isBanned(userId);
}
/**
 * @description API2 형식 명령어 파싱
 * @param {string} content 메시지 내용
 * @param {string} [prefix] 명령어 접두사 (기본값: CMD_PREFIX)
 * @returns {{cmd: string, args: string[], payload: string}} 명령어, 인자 배열, 전체 payload
 * @example
 * const { cmd, args } = parseCommand("!밴 @user 사유");
 * // { cmd: "밴", args: ["@user", "사유"], payload: "밴 @user 사유" }
 */
function parseCommand(content, prefix) {
    const pre = prefix || CMD_PREFIX;

    if (!content || !content.startsWith(pre)) {
        return { cmd: "", args: [], payload: "" };
    }

    const payload = content.slice(pre.length).trim();
    const [rawCmd, ...args] = payload.split(/\s+/);
    const cmd = rawCmd.toLowerCase();

    return { cmd, args, payload };
}


/**
 * @description 막대 그래프 (가로)
 * @param {number} now 현재값
 * @param {number} max 최대값
 * @param {number} totalBlocks 막대 블록 수 (1~20, 기본 10)
 * @returns {string} 막대 그래프
 */
function toBar(now, max, totalBlocks) {
    totalBlocks = totalBlocks || 10;
    if ((!now && now != 0) || (!max && max != 0) || now > max || isNaN(now + max + totalBlocks)) return "올바른 숫자를 입력해주세요";
    
    totalBlocks = Math.floor(totalBlocks);
    totalBlocks = totalBlocks < 1 ? 1 : totalBlocks > 20 ? 20 : totalBlocks;

    const ratio = now / max * totalBlocks;
    const filled = Math.floor(ratio);
  
    const bar = ['　', '▏', '▎', '▍', '▌', '▋', '▊', '▉', '█'];   // 0은 공백
    
    return filled === totalBlocks ? 
        bar[8].repeat(filled) :
        bar[8].repeat(filled) + bar[((ratio - filled) * 8 + 0.5) | 0] + bar[0].repeat(totalBlocks - filled - 1);
}
/**
 * @description 세로 막대 그래프
 * @param {string[]} names 항목 이름 배열
 * @param {number[]} values 항목 값 배열
 * @param {number} [max=Math.max.apply(null, values)] 최대값
 * @param {boolean} [needSort=false] 정렬 여부
 * @returns {string} 세로 막대 그래프 문자열
 */
function toVerticalBar(names, values, max, needSort) { 
    if (!names || !values) return "올바른 입력을 해주세요";
    if (names.length !== values.length) return "이름과 값의 수가 다릅니다";
    if (names.length > 20) return "항목은 최대 20개입니다";
  
    const numbersStr = "①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳";
    const barSymbols = "▁▂▃▄▅▆▇█";
    const totalRows = 8;
    max = max || Math.max.apply(null, values);
  
    const data = names.map((name, i) => ({ 
        name, 
        value: values[i], 
        origIndex: i, 
        num: 0
    }));
  
    // 내림차순 정렬한 배열
    let sortedData = data.slice().sort((a, b) => b.value - a.value);
    if (needSort) sortedData.forEach((item, i) => item.num = i + 1);
    else data.forEach((item, i) => item.num = i + 1);
  
    // 각 항목별 막대 높이 계산
    for (let item of sortedData) {
        let raw = (item.value / max) * totalRows;
        item.full = Math.floor(raw);
        item.hasPartial = raw > item.full;
        item.fraction = item.hasPartial ? raw - item.full : 0;
    }
  
    // 그래프 행 구성
    const graphRows = [];
    for (let row = totalRows; row >= 1; row--) {
        let rowSymbols = [];
        for (let item of sortedData) {
            if (row <= item.full) {
                rowSymbols.push("█");
            } else if (item.hasPartial && row === item.full + 1) {
                let idx = (item.fraction < 0.5) ? Math.floor(item.fraction * 7) 
                                                : Math.round(item.fraction * 7);
                if (idx < 0) idx = 0;
                if (idx > 6) idx = 6;
                rowSymbols.push(barSymbols.charAt(idx));
            } else {
                rowSymbols.push(" ");
            }
        }
    
        graphRows.push("│" + rowSymbols.join(" ").replace(/\s+$/, ""));
    }
  
    const xAxisRow = "│" + sortedData.map(item => numbersStr.charAt(item.num - 1)).join(" ");
    const graphOutput = graphRows.join("\n") + "\n" + xAxisRow;
  
    const legendData = needSort ?
        sortedData :
        data.sort((a, b) => a.origIndex - b.origIndex);
  
    const legendOutput = legendData.map(item => {
        let circledNum = numbersStr.charAt(item.num - 1);
        return `${circledNum} ${item.name} (${item.value})`;
    }).join("\n");
  
    return graphOutput + "\n\n" + legendOutput;
}
/** @description 숫자 3자리 마다 쉼표 */
function splitNum(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


/**
 * @description 환율 정보 업데이트 (100달러 당 원화)
 * @return {number} currentDollar
 */
function getDollar() {
    try {
        const url = "https://m.search.naver.com/p/csearch/content/qapirender.nhn?key=calculator&pkid=141&q=%ED%99%98%EC%9C%A8&where=m&u1=keb&u6=standardUnit&u7=0&u3=USD&u4=KRW&u8=down&u2=100";
        const html = Jsoup.connect(url)
            .ignoreContentType(true)
            .ignoreHttpErrors(true)
            .get().text();
        const currentDollar = JSON.parse(html).country[1].value.replace(",", "");
        return Number(currentDollar);
    } catch(e) {
        Logger.e(_SCRIPT_NAME, e);
        return 140000;
    }
}


/** @description 메모리 사용량 체크 */
function logMemory() {
    const totalMemory = Runtime.getRuntime().totalMemory();
    const freeMemory = Runtime.getRuntime().freeMemory();
    const maxMemory = Runtime.getRuntime().maxMemory();
    // const heap = ManagementFactory.getMemoryMXBean().getHeapMemoryUse();
    return { totalMemory, freeMemory, maxMemory };
}


module.exports = {
    executeQuery,
    irisReply,
    isAdmin, isBanned,
    toBar, toVerticalBar, splitNum,
    getDollar,
    logMemory,
    parseCommand
};