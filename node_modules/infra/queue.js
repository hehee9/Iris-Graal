/**
 * @file node_modules/infra/queue.js
 * @description 텍스트/미디어 전송 큐. 독립 파이프 + 최소 간격 보장
 * @todo 텍스트/파일 전송 결과가 true임에도 전송되지 않은 케이스 재시도.
 * isMine인 메시지가 오는지 검사하면 됨
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "queue.js";
const { Logger } = require("shared/logger");
const { sendTextNow, sendFileNow, resolveIdentifier } = require("infra/sender");
const {
    TEXT_TERM, MEDIA_TERM, FILE_DOWNLOAD_TIMEOUT,
    SEND_RETRY_MAX, RETRY_BACKOFF_MS, PUMP_INTERVAL_MS
} = require("shared/config");
const ConcurrentLinkedQueue = Java.type("java.util.concurrent.ConcurrentLinkedQueue");
const bot = BotManager.getCurrentBot();


// 인박스
const inTextInbox = new ConcurrentLinkedQueue();
const inMediaInbox = new ConcurrentLinkedQueue();
const inAckInbox = new ConcurrentLinkedQueue();
let pumpId = null;


let textTimer = null;
let runningText = false;
let lastTextAt = 0;
const qText = [];


let mediaTimer = null;
let runningMedia = false;
let lastMediaAt = 0;
const qMedia = [];


const _lastAckByRoom = Object.create(null);




/* =================================== 유틸/헬퍼 =================================== */


/** @description 인박스 플러시, 스크립트 스레드에서만 호출 */
function _flushTextInbox() {
    while (!inTextInbox.isEmpty()) qText.push(inTextInbox.poll());
}
function _flushMediaInbox() {
    while (!inMediaInbox.isEmpty()) qMedia.push(inMediaInbox.poll());
}
function _flushAckInbox() {
    while (!inAckInbox.isEmpty()) {
        const item = inAckInbox.poll();
        if (!item) continue;
        _lastAckByRoom[item.roomKey] = item.time;
    }
}


/** @description 텍스트 파이프 드레인 */
function _drainText() {
    if (!runningText) return;

    _flushTextInbox();

    if (qText.length === 0) {
        textTimer = null;
        return;
    }
  
    const now = Date.now();
    const wait = Math.max(0, lastTextAt + TEXT_TERM - now);
  
    textTimer = setTimeout(() => {
        const job = qText.shift();
        let ok = false;
        const sentAt = Date.now();
        try {
            ok = sendTextNow(job.target, job.text);
            if (!ok) {
                const tries = (job.tries || 0) + 1;
                if (tries <= SEND_RETRY_MAX) {
                    qText.push({ ...job, tries });
                }
            }
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
        } finally {
            lastTextAt = ok ? sentAt : (sentAt - TEXT_TERM + RETRY_BACKOFF_MS);
        }
        _drainText();
    }, wait);
}
/** @description 미디어 파이프 드레인 */
function _drainMedia() {
    if (!runningMedia) return;

    _flushMediaInbox();

    if (qMedia.length === 0) {
        mediaTimer = null;
        return;
    }
  
    const now = Date.now();
    const wait = Math.max(0, lastMediaAt + MEDIA_TERM - now);
  
    mediaTimer = setTimeout(() => {
        const job = qMedia.shift();
        let ok = false;
        const sentAt = Date.now();
        try {
            const timeout = job.timeoutMs ?? FILE_DOWNLOAD_TIMEOUT;
            ok = sendFileNow(job.target, job.media, timeout, job.fileName);
            if (!ok) {
                const tries = (job.tries || 0) + 1;
                if (tries <= SEND_RETRY_MAX) {
                    qMedia.push({ ...job, tries });
                }
            }
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
        } finally {
            lastMediaAt = ok ? sentAt : (sentAt - MEDIA_TERM + RETRY_BACKOFF_MS);
        }
        _drainMedia();
    }, wait);
}


/** @description pump 루프 */
function _pump() {
    try {
        _flushAckInbox();

        if (runningText) {
            _flushTextInbox();
            if (!textTimer && qText.length > 0) {
                _drainText();
            }
        }

        if (runningMedia) {
            _flushMediaInbox();
            if (!mediaTimer && qMedia.length > 0) {
                _drainMedia();
            }
        }
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }
}




/* =================================== 메인 로직 =================================== */


/** @description 텍스트 enqueue */
function enqueueText(target, text) {
    if (!target || !text) return;
    inTextInbox.add({ target: resolveIdentifier(target), text });
}
/** @description 미디어 enqueue */
function enqueueMedia(target, media, timeoutMs, fileName) {
    if (!target || !media) return;
    inMediaInbox.add({
        target: resolveIdentifier(target),
        media, timeoutMs, fileName
    });
}


/**
 * @description (옵저빙) 파이프 외부에서 들어오는 self 메시지를 기록
 * @param {import("shared/types").Message} msg
 */
function onInboundMessage(msg) {
    try {
        if (!msg?.isMine) return;
        const roomId = msg.room?.channelId;
        if (!roomId) return;
        inAckInbox.add({ roomKey: String(roomId), time: Date.now() });
        // todo: 특정 시간 내 ack 없음 → 재시도 가중 등 정책에 활용
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }
}


/** @description 두 파이프 시작 */
function start() {
    if (!runningText) runningText = true;
    if (!runningMedia) runningMedia = true;
    if (!pumpId) {
        const interval = PUMP_INTERVAL_MS;
        pumpId = setInterval(_pump, interval);
        _pump();
    }
}
/** @description 두 파이프 중단 */
function stop() {
    runningText = false;
    runningMedia = false;

    if (textTimer) {
        clearTimeout(textTimer);
        textTimer = null;
    }
    if (mediaTimer) {
        clearTimeout(mediaTimer);
        mediaTimer = null;
    }
    if (pumpId) {
        clearInterval(pumpId);
        pumpId = null;
    }
}


/** @description 전체 큐 길이 */
function size() { return qText.length + qMedia.length + inTextInbox.size() + inMediaInbox.size(); }
/** @description 텍스트 큐 길이 */
function sizeText() { return qText.length + inTextInbox.size(); }
/** @description 미디어 큐 길이 */
function sizeMedia() { return qMedia.length + inMediaInbox.size(); }


bot.addListener(Event.START_COMPILE, () => {
    stop();
    qText.length = 0;
    qMedia.length = 0;

    while (!inTextInbox.isEmpty()) inTextInbox.poll();
    while (!inMediaInbox.isEmpty()) inMediaInbox.poll();
    while (!inAckInbox.isEmpty()) inAckInbox.poll();
});


module.exports = {
    enqueueText, enqueueMedia,
    onInboundMessage,
    start, stop,
    size, sizeText, sizeMedia
};