/**
 * @file node_modules/infra/httpServer.js
 * @description Iris 통신
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "httpServer.js";
const { Logger } = require("shared/logger");
const {
    IRIS_PORT, IRIS_ENDPOINT, IRIS_OK, IRIS_BAD_REQUEST,
    IRIS_INTERNAL_ERROR, PUMP_INTERVAL_MS
} = require("shared/config");
const bot = BotManager.getCurrentBot();

const ServerSocket = Java.type("java.net.ServerSocket");
const SocketException = Java.type("java.net.SocketException");
const ByteArrayOutputStream = Java.type("java.io.ByteArrayOutputStream");
const StandardCharsets = Java.type("java.nio.charset.StandardCharsets");
const Executors = Java.type("java.util.concurrent.Executors");
const TimeUnit = Java.type("java.util.concurrent.TimeUnit");
const Thread = Java.type("java.lang.Thread");
const JString = Java.type("java.lang.String");
const ByteArray = Java.type("byte[]");
const Runnable = Java.type("java.lang.Runnable"); // GraalJS: SAM 명시 래핑용
const ConcurrentLinkedQueue = Java.type("java.util.concurrent.ConcurrentLinkedQueue");
const inbox = new ConcurrentLinkedQueue();

let server = null;
let running = false;
let executorService = null;
let serverThread = null;
let pumpTimer = null;




/* =================================== 헬퍼/유틸 =================================== */

/** @description 스크립트 쓰레드에서 큐 드레인 */
function _drain() {
    try {
        let item;
        // poll로 모두 비움
        while ((item = inbox.poll()) != null) {
            try {
                module.exports.onPost(item);
            } catch (e) {
                Logger.e(_SCRIPT_NAME, e);
            }
        }
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }
}
function _startPump() {
    if (!pumpTimer) pumpTimer = setInterval(_drain, PUMP_INTERVAL_MS);
}
function _stopPump() {
    if (pumpTimer) { clearInterval(pumpTimer); pumpTimer = null; }
}


/**
 * @description HTTP 응답 전송
 * @param {java.net.Socket} socket
 * @param {java.io.OutputStream} out
 * @param {string} response
 */
function _sendHttpResponse(socket, out, response) {
    try {
        if (socket && !socket.isClosed() && !socket.isOutputShutdown() && out) {
            const jstr = new JString(response);
            out.write(jstr.getBytes(StandardCharsets.UTF_8));
            out.flush();
        }
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    }
}
/**
 * @description 한 줄을 CRLF까지 읽어 바이트 배열로 반환. EOF 시 null.
 * @param {java.io.InputStream} inStream
 * @returns {byte[]|null}
 */
function _readLineBytes(inStream) {
    const buf = new ByteArrayOutputStream();
    let prev = -1;
    let curr;

    try {
        while ((curr = inStream.read()) !== -1) {
            if (prev === 0x0D && curr === 0x0A) {
                return buf.toByteArray();
            } else {
                buf.write(curr);
                prev = curr;
            }
        }
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
        return null;
    }

    return buf.size() > 0 ? buf.toByteArray() : null;
}


/** @description attachment JSON 문자열 내 큰 정수 ID 키를 문자열로 강제 */
function _quoteBigIntIds(jsonText) {
    // 키 목록 (필요 시 확장)
    const ID_KEYS = [
        "src_logId", "src_userId",
        "user_id", "chat_id", "id", "prev_id", "client_message_id",
        "src_id", "msg_id"
    ];
    const pattern = new RegExp(
        `"(${ID_KEYS.join("|")})"\\s*:\\s*(-?\\d{15,})(?=\\s*[,}\\]])`,
        "g"
    );
    return jsonText.replace(pattern, (_match, key, num) => `"${key}": "${num}"`);
}




/* =================================== 메인 로직 =================================== */


/** @description 서버 accept 루프 */
function run() {
    executorService = Executors.newSingleThreadExecutor();
    try {
        server = new ServerSocket(IRIS_PORT);
        Logger.i(_SCRIPT_NAME, `서버 시작됨 (포트: ${IRIS_PORT})`);
        running = true;

        while (running) {
            let sock = null;
            try {
                sock = server.accept();
                sock.setSoTimeout(10000);
                const client = sock;

                // Runnable 명시 래핑으로 submit 오버로드 모호성 제거
                executorService.execute(new Runnable({
                    run: function () {
                        try {
                            const inStream = client.getInputStream();
                            const outStream = client.getOutputStream();

                            // 요청라인
                            const rl = _readLineBytes(inStream);
                            if (!rl) {
                                _sendHttpResponse(client, outStream, IRIS_BAD_REQUEST);
                                return;
                            }

                            const reqLine = String(new JString(rl, StandardCharsets.UTF_8)).trim();
                            if (!reqLine.startsWith("POST " + IRIS_ENDPOINT)) {
                                _sendHttpResponse(client, outStream, IRIS_BAD_REQUEST);
                                return;
                            }

                            // 헤더 읽기
                            const headers = {};
                            let len = 0;
                            let hb;

                            while ((hb = _readLineBytes(inStream)) !== null) {
                                if (hb.length <= 2) break; // 빈 줄(헤더 끝)
                                const line = String(new JString(hb, StandardCharsets.UTF_8)).trim();
                                const idx = line.indexOf(":");
                                if (idx > 0) {
                                    const k = line.slice(0, idx).trim().toLowerCase();
                                    const v = line.slice(idx + 1).trim();
                                    headers[k] = v;
                                    if (k === "content-length") {
                                        try {
                                            len = parseInt(v);
                                            if (len < 0) len = 0;
                                        } catch (_) {
                                            _sendHttpResponse(client, outStream, IRIS_BAD_REQUEST);
                                            return;
                                        }
                                    }
                                }
                            }

                            // 본문 읽기
                            let bodyJS = "";
                            if (len > 0) {
                                const bufBytes = new ByteArray(len);
                                let total = 0;
                                let readn;

                                while (total < len && (readn = inStream.read(bufBytes, total, len - total)) !== -1) {
                                    if (readn === 0) { Thread.sleep(10); continue; }
                                    total += readn;
                                }

                                if (total !== len) {
                                    _sendHttpResponse(client, outStream, IRIS_INTERNAL_ERROR);
                                    return;
                                }

                                const jb = new JString(bufBytes, StandardCharsets.UTF_8);
                                bodyJS = String(jb);
                            }

                            // JSON 파싱
                            let data = {};
                            if (bodyJS.length > 0) {
                                try {
                                    data = JSON.parse(bodyJS);
                                } catch (e) {
                                    Logger.e(_SCRIPT_NAME, e);
                                    _sendHttpResponse(client, outStream, IRIS_BAD_REQUEST);
                                    return;
                                }

                                // 중첩 JSON 파싱
                                if (typeof data.msg === "string") {
                                    try { data.msg = JSON.parse(data.msg); } catch (_) {}
                                }
                                if (data.json) {
                                    ["message", "attachment", "v"].forEach((field) => {
                                        let val = data.json[field];
                                        if (typeof val === "string") {
                                            try {
                                                if (field === "attachment") {
                                                    val = _quoteBigIntIds(val);
                                                }
                                                data.json[field] = JSON.parse(val);
                                            } catch (_) { /* 파싱 실패 시 원본 유지 */ }
                                        }
                                    });
                                }
                            }

                            inbox.add(data);
                            _sendHttpResponse(client, outStream, IRIS_OK);
                        } catch (e) {
                            Logger.e(_SCRIPT_NAME, e);
                            try { _sendHttpResponse(client, client.getOutputStream(), IRIS_INTERNAL_ERROR); } catch (_) {}
                        } finally {
                            try { if (client && !client.isClosed()) client.close(); }
                            catch (e) { Logger.e(_SCRIPT_NAME, e); }
                        }
                    }
                }));
            } catch (e) {
                if (!(e instanceof SocketException && running === false) && running) {
                    Logger.e(_SCRIPT_NAME, e);
                }
                if (sock && !sock.isClosed()) {
                    try { sock.close(); }
                    catch (ee) { Logger.e(_SCRIPT_NAME, ee); }
                }
            }
        }
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
    } finally {
        Logger.i(_SCRIPT_NAME, "서버 종료 중...");
        stopServer();
        Logger.i(_SCRIPT_NAME, "서버 종료됨");
    }
}




/* =================================== 핸들링 =================================== */


/** @description 수신한 데이터 전송 */
function onPost(json) {
    return json;
}
/** @description 서버 시작 (중복 기동 방지) */
function startServer() {
    if (serverThread !== null || running) {
        Logger.w(_SCRIPT_NAME, "서버가 이미 실행 중이거나 시작 중입니다.");
        return;
    }
    _startPump();
    serverThread = new Thread(new Runnable({ run: run }));
    serverThread.setName("GraalHttpServerThread");
    serverThread.start();
}
/** @description 서버 소켓, 스레드 풀 종료 */
function stopServer() {
    running = false;
    _stopPump();

    // ExecutorService 종료
    if (executorService !== null) {
        try {
            executorService.shutdown();
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            try { executorService.shutdownNow(); } catch (_) {}
        }
        executorService = null;
    }

    // ServerSocket 종료
    if (server !== null && !server.isClosed()) {
        try { server.close(); }
        catch (e) { Logger.e(_SCRIPT_NAME, e); }
    }
    server = null;
    serverThread = null;
}


bot.addListener(Event.START_COMPILE, () => { _stopPump(); });


module.exports = { startServer, stopServer, onPost };