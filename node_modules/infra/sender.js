/**
 * @file node_modules/infra/sender.js
 * @description 텍스트/미디어 송신 래퍼
 * - MediaSender의 경우, Java Byte[], Base64 입력 및 모든 경로 입력 지원
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "sender.js";
const { Logger } = require("shared/logger");
const { FILE_DOWNLOAD_TIMEOUT } = require("shared/config");
const bot = BotManager.getCurrentBot();
const mediaSender = new MediaSender();


const Jsoup = Java.type("org.jsoup.Jsoup");
const FileOutputStream = Java.type("java.io.FileOutputStream");
const BufferedOutputStream = Java.type("java.io.BufferedOutputStream");
const Base64 = Java.type("android.util.Base64");
const ByteBuffer = Java.type("java.nio.ByteBuffer");
const ArrayReflect = Java.type("java.lang.reflect.Array");


class FatalSendError extends Error {}




/* =================================== 유틸/헬퍼 =================================== */


/** @description path 끝에 슬래시 보장 */
function _ensureTrailingSlash(p) {
    return p.endsWith("/") ? p : (p + "/");
}
/** @description 파일명 안전화 */
function _sanitizeFileName(name) {
    return name.replace(/[\\/:*?"<>|\0]/g, "_");
}
/** @description 확장자 강제 부착 */
function _attachExtIfAbsent(name, ext) {
    if (!ext) return name;
    const dot = name.lastIndexOf(".");
    if (dot === -1) return `${name}.${ext}`;
    return name;
}


/** @description Java byte[] 변환 */
function _toJavaByteArray(x) {
    if (!x) return null;

    // Graal JS 네이티브 체크
    if (typeof Java !== "undefined") {
        if (Java.isJavaObject) {
            const isJava = Java.isJavaObject(x);

            if (isJava) {
                if (Java.typeName) {
                    const typeName = Java.typeName(x);
                    if (typeName === "byte[]") {
                        return x;
                    }
                }

                const ByteArrayClass = Java.type("byte[]");
                const isInstance = x instanceof ByteArrayClass;
                if (isInstance) return x;
            }
        }
    }

    // getClass()
    if (x.getClass) {
        const cls = x.getClass();
        const clsName = cls.getName();
        
        if (clsName === "[B") return x;
        
        if (cls.isArray && cls.isArray()) {
            const comp = cls.getComponentType();
            if (comp) {
                const compName = comp.getName();
                if (compName === "byte") return x;
            }
        }
    }

    // ArrayReflect
    try {
        const len = ArrayReflect.getLength(x);
        if (len >= 0) {
            if (len > 0) {
                const first = ArrayReflect.get(x, 0);
                if (typeof first === "number" && first >= -128 && first <= 127) {
                    return x;
                }
            } else {
                const cls = x.getClass();
                const comp = cls.getComponentType();
                if (comp && comp.getName() === "byte") {
                    return x;
                }
            }
        }
    } catch (_) { }

    // 직접 length
    if (typeof x === "object" && x !== null && typeof x.length === "number" && x.length > 0) {
        const val = x[0];
        
        if (typeof val === "number" && val >= -128 && val <= 127) {
            return x;
        }
    }

    // ByteBuffer
    if (ByteBuffer.class.isInstance(x)) {
        const bb = x;
        const len = bb.remaining();
        const BA = Java.type("byte[]");
        const out = new BA(len);
        bb.get(out);
        return out;
    }

    // JS TypedArray
    if (typeof x === "object" && x !== null && x.BYTES_PER_ELEMENT === 1 && typeof x.length === "number") {
        const BA = Java.type("byte[]");
        const out = new BA(x.length);
        for (let i = 0; i < x.length; i++) out[i] = x[i] & 0xFF;
        return out;
    }

    return null;
}
/** @description Base64 판별 */
function _isLikelyRawBase64(s) {
    if (typeof s !== "string") return false;
    const trimmed = s.trim();
    if (trimmed.length < 64) return false;
    const cleaned = trimmed.replace(/\s+/g, "");
    if (!/^[A-Za-z0-9+\/\-_+=]+$/.test(cleaned)) return false;
    try {
        Base64.decode(cleaned, Base64.DEFAULT);
        return true;
    } catch (e) {
        try {
            Base64.decode(cleaned, Base64.URL_SAFE);
            return true;
        } catch (_) {
            return false;
        }
    }
}
/** @description base64 디코더 */
function _decodeBase64Flexible(b64) {
    let cleaned = b64.replace(/\s+/g, "");
    const mod4 = cleaned.length % 4;
    if (mod4 !== 0) cleaned += "===".slice(mod4);

    try {
        return Base64.decode(cleaned, Base64.DEFAULT);
    } catch (e) {
        try {
            return Base64.decode(cleaned, Base64.URL_SAFE);
        } catch (e2) {
            const replaced = cleaned.replace(/-/g, "+").replace(/_/g, "/");
            let m = replaced.length % 4;
            let pad = (m !== 0) ? "===".slice(m) : "";
            return Base64.decode(replaced + pad, Base64.DEFAULT);
        }
    }
}


/** @description byte[] → 파일 저장 */
function _writeBytes(path, bytes) {
    let fos = null, bos = null;
    try {
        const parent = FileStream.getParentPath(path);
        if (parent) FileStream.createDir(parent);
        fos = new FileOutputStream(path);
        bos = new BufferedOutputStream(fos);
        bos.write(bytes);
        bos.flush();
    } finally {
        try { if (bos) bos.close(); } catch (_) {}
        try { if (fos) fos.close(); } catch (_) {}
    }
}
/** @description mime→ext 매핑 */
function _mimeToExt(mime) {
    if (!mime) return null;
    const key = mime.toLowerCase().split(";")[0].trim();

    const MAP = _mimeToExt._MAP || (_mimeToExt._MAP = {
        // 이미지
        "image/jpeg": "jpg", "image/jpg": "jpg",
        "image/gif": "gif",
        "image/bmp": "bmp", "image/x-ms-bmp": "bmp",
        "image/png": "png",
        "image/tiff": "tif", // 대표 확장자 tif
        "image/x-tga": "tga",
        "image/vnd.adobe.photoshop": "psd",
        "application/postscript": "ai",
        "image/webp": "webp",
        "image/avif": "avif",
        "image/heic": "heic",

        // 동영상
        "video/mp4": "mp4",
        "video/x-msvideo": "avi",
        "video/x-ms-asf": "asf",
        "video/x-ms-wmv": "wmv",
        "video/x-matroska": "mkv",
        "video/mp2t": "ts",
        "video/mpeg": "mpg",
        "video/quicktime": "mov",
        "video/x-flv": "flv",
        "video/ogg": "ogv",

        // 오디오
        "audio/mpeg": "mp3",
        "audio/wav": "wav", "audio/x-wav": "wav", "audio/wave": "wav",
        "audio/flac": "flac",
        "audio/x-tta": "tta",
        "audio/x-tak": "tak",
        "audio/aac": "aac",
        "audio/x-ms-wma": "wma",
        "audio/ogg": "ogg",
        "audio/mp4": "m4a",

        // 문서 및 기타
        "application/msword": "doc",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
        "application/x-hwp": "hwp",
        "text/plain": "txt",
        "application/rtf": "rtf",
        "application/xml": "xml", "text/xml": "xml",
        "application/pdf": "pdf",
        "application/vnd.ms-works": "wks",
        "application/vnd.ms-xpsdocument": "xps",
        "text/markdown": "md",
        "application/vnd.oasis.opendocument.text": "odt",
        "application/vnd.oasis.opendocument.spreadsheet": "ods",
        "application/vnd.oasis.opendocument.presentation": "odp",
        "application/vnd.oasis.opendocument.formula": "odf", // 보강
        "text/csv": "csv",
        "text/tab-separated-values": "tsv",
        "application/vnd.ms-excel": "xls",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
        "application/vnd.ms-powerpoint": "ppt",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
        "application/x-iwork-pages-sffpages": "pages",
        "application/x-iwork-keynote-sffkey": "key",
        "application/x-iwork-numbers-sffnumbers": "numbers",
        "application/octet-stream": "bin",

        // 압축파일
        "application/zip": "zip", "application/x-zip-compressed": "zip",
        "application/gzip": "gz", "application/x-gzip": "gz",
        "application/x-bzip2": "bz2", "application/bzip2": "bz2",
        "application/x-rar-compressed": "rar", "application/vnd.rar": "rar",
        "application/x-7z-compressed": "7z",
        "application/x-lzh": "lzh", "application/x-lzh-compressed": "lzh",
        "application/x-alz-compressed": "alz"
    });

    return MAP[key] || null;
}


/**
 * @description 단일 리소스를 MediaSender가 처리 가능한 형태로 준비
 * @param {string|byte[]} resource 경로|URL|dataURL|base64|Java byte[]
 * @param {string|undefined} fileNameHint 원하는 파일명(옵션)
 * @returns {string|null} 준비된 경로 또는 URL
 */
function _prepareOne(resource, fileNameHint) {
    const baseDir = _ensureTrailingSlash(mediaSender.getBaseDirectory());
    try { FileStream.createDir(baseDir); } catch (_) {}

    // byte[] / ByteBuffer / TypedArray
    const asBytes = _toJavaByteArray(resource);
    if (asBytes) {
        const extHint = fileNameHint ? FileStream.getExtension(fileNameHint) : "";
        const ext = extHint ? extHint.toLowerCase() : "jpg";
        const targetName = _sanitizeFileName(fileNameHint ? _attachExtIfAbsent(fileNameHint, ext) : `${Date.now()}.${ext}`);
        const outPath = baseDir + targetName;
        try {
            _writeBytes(outPath, asBytes);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return null;
        }
        return outPath;
    }

    // 문자열 처리
    if (typeof resource !== "string") {
        Logger.w(_SCRIPT_NAME, "지원하지 않는 미디어 입력 타입");
        throw new FatalSendError("지원하지 않는 미디어 입력 타입");
    }

    // data URL
    if (resource.startsWith("data:")) {
        const comma = resource.indexOf(",");
        if (comma <= 5) return null;
        const header = resource.slice(5, comma); // "image/png;base64"
        const semi = header.indexOf(";");
        const mime = semi === -1 ? header : header.slice(0, semi);
        const payload = resource.slice(comma + 1);
        const bytes = _decodeBase64Flexible(payload);
        const ext = _mimeToExt(mime) || (fileNameHint ? FileStream.getExtension(fileNameHint) : "") || "jpg";
        const targetName = _sanitizeFileName(fileNameHint ? _attachExtIfAbsent(fileNameHint, ext) : `${Date.now()}.${ext}`);
        const outPath = baseDir + targetName;
        try {
            _writeBytes(outPath, bytes);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return null;
        }
        return outPath;
    }

    // base64
    if (resource.startsWith("base64:") || resource.startsWith("base64,")) {
        const bytes = _decodeBase64Flexible(resource.slice(7));
        const extHint = fileNameHint ? FileStream.getExtension(fileNameHint) : "";
        const ext = (extHint ? extHint.toLowerCase() : "jpg");
        const targetName = _sanitizeFileName(fileNameHint ? _attachExtIfAbsent(fileNameHint, ext) : `${Date.now()}.${ext}`);
        const outPath = baseDir + targetName;
        try {
            _writeBytes(outPath, bytes);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return null;
        }
        return outPath;
    }

    // raw base64
    if (_isLikelyRawBase64(resource)) {
        const bytes = _decodeBase64Flexible(resource);
        const extHint = fileNameHint ? FileStream.getExtension(fileNameHint) : "";
        const ext = (extHint ? extHint.toLowerCase() : "jpg");
        const targetName = _sanitizeFileName(fileNameHint ? _attachExtIfAbsent(fileNameHint, ext) : `${Date.now()}.${ext}`);
        const outPath = baseDir + targetName;
        try {
            _writeBytes(outPath, bytes);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return null;
        }
        return outPath;
    }

    // URL
    if (resource.startsWith("http://") || resource.startsWith("https://")) {
        if (!fileNameHint) return resource;

        try {
            const resp = Jsoup.connect(resource)
                .ignoreContentType(true)
                .ignoreHttpErrors(true)
                .maxBodySize(0)
                .timeout(FILE_DOWNLOAD_TIMEOUT)
                .execute();

            const bytes = resp.bodyAsBytes();

            let ext = FileStream.getExtension(fileNameHint);
            if (!ext) {
                const ct = resp.contentType();
                const mime = ct ? ct.split(";")[0].trim() : null;
                ext = _mimeToExt(mime) || FileStream.getExtension(resource) || "dat";
            }

            const targetName = _sanitizeFileName(_attachExtIfAbsent(fileNameHint, ext));
            let outPath = baseDir + targetName;

            // 동일 파일명 존재 시 타임스탬프 부착
            if (FileStream.isFile(outPath)) {
                const e = FileStream.getExtension(targetName);
                const base = e ? targetName.slice(0, -(e.length + 1)) : targetName;
                outPath = baseDir + `${base}_${Date.now()}${e ? "." + e : ""}`;
            }

            _writeBytes(outPath, bytes);
            return outPath;
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return null;
        }
    }

    // 로컬 파일 경로
    const abs = resource;
    const isInBase = abs.startsWith(baseDir);

    if (fileNameHint) {
        const srcExt = FileStream.getExtension(fileNameHint) || FileStream.getExtension(abs);
        const targetName = _sanitizeFileName(_attachExtIfAbsent(fileNameHint, srcExt));
        let dest = baseDir + targetName;
        if (abs === dest) return abs;

        if (FileStream.isFile(dest)) {
            const ext = FileStream.getExtension(targetName);
            const base = ext ? targetName.slice(0, -(ext.length + 1)) : targetName;
            dest = baseDir + `${base}_${Date.now()}${ext ? "." + ext : ""}`;
        }
        return FileStream.copyFile(abs, dest) ? dest : null;
    }

    // baseDir
    if (!isInBase) {
        const name = FileStream.getFileName(abs) || `${Date.now()}.dat`;
        let safeName = _sanitizeFileName(name);
        let dest = baseDir + safeName;
        if (FileStream.isFile(dest)) {
            const ext = FileStream.getExtension(safeName);
            const base = ext ? safeName.slice(0, -(ext.length + 1)) : safeName;
            dest = baseDir + `${base}_${Date.now()}${ext ? "." + ext : ""}`;
        }
        return FileStream.copyFile(abs, dest) ? dest : null;
    }

    return abs;
}




/* =================================== 메인 로직 =================================== */


/**
 * @description 숫자 문자열이면 bigint로 변환, 그 외는 방 이름
 * @param {string|bigint} id
 * @returns {string|bigint|null}
 */
function resolveIdentifier(id) {
    if (!id) return null;
    if (typeof id === "bigint") return id;
    if (typeof id === "string") {
        const s = id.trim();
        if (s === "") return null;
        if (/^\d+$/.test(s)) return BigInt(s);
        return s; // 방 이름
    }
    return null;
}


/**
 * @description 즉시 텍스트 전송
 * @param {string|bigint} target 대상 방
 * @param {string} content
 * @returns {boolean}
 */
function sendTextNow(target, content) {
    if (!target || !content) return false;
    return bot.send(resolveIdentifier(target), content);
}
/**
 * @description 즉시 파일 전송 (개선)
 * - 4번째 파라미터(fileName)로 저장/전송 파일명 지정 가능
 * - Java byte[] / base64 입력 지원
 * @param {string|bigint} target
 * @param {string|string[]|any} path 경로/URL/byte[]/base64/배열
 * @param {number} [timeoutMs=FILE_DOWNLOAD_TIMEOUT]
 * @param {string} [fileName] 저장/전송에 사용할 파일명
 * @returns {boolean}
 */
function sendFileNow(target, path, timeoutMs = FILE_DOWNLOAD_TIMEOUT, fileName) {
    if (!target || !path) return false;
    const resolvedTarget = resolveIdentifier(target);

    try {
        const asByteArray = _toJavaByteArray(path);
        if (asByteArray) {
            const prepared = _prepareOne(path, fileName);
            if (!prepared) return false;
            return mediaSender.send(resolvedTarget, prepared, timeoutMs);
        }

        // ByteBuffer 체크
        try {
            if (ByteBuffer.class.isInstance(path)) {
                const prepared = _prepareOne(path, fileName);
                if (!prepared) return false;
                return mediaSender.send(resolvedTarget, prepared, timeoutMs);
            }
        } catch (_) {}

        // TypedArray 체크
        if (typeof path === "object" && path !== null && path.BYTES_PER_ELEMENT === 1) {
            const prepared = _prepareOne(path, fileName);
            if (!prepared) return false;
            return mediaSender.send(resolvedTarget, prepared, timeoutMs);
        }

        // 복수 파일
        if (Array.isArray(path)) {
            const prepared = [];
            for (let i = 0; i < path.length; i++) {
                let nameHint;
                if (typeof fileName === "string" && fileName.length) {
                    const ext = FileStream.getExtension(fileName);
                    if (ext) {
                        const base = fileName.slice(0, -(ext.length + 1));
                        nameHint = `${base}_${i + 1}.${ext}`;
                    } else {
                        nameHint = `${fileName}_${i + 1}`;
                    }
                }
                const p = _prepareOne(path[i], nameHint);
                if (p) prepared.push(p);
            }
            if (prepared.length === 0) return false;
            return mediaSender.send(resolvedTarget, prepared, timeoutMs);
        }

        // 단일 파일
        const prepared = _prepareOne(path, fileName);
        if (!prepared) return false;
        return mediaSender.send(resolvedTarget, prepared, timeoutMs);
    } catch (e) {
        if (e instanceof FatalSendError) throw e;
        Logger.e(_SCRIPT_NAME, e);
        return false;
    }
}


module.exports = { resolveIdentifier, sendTextNow, sendFileNow };