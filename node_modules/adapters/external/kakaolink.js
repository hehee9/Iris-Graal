/**
 * @file node_modules/adapters/external/kakaolink.js
 * @description KakaoLink 전송 모듈
 * @see https://github.com/ye-seola/kakaolink-py
 */


/**
 * @typedef {object} KakaoLinkOptions
 * @property {string} app_key // 필수
 * @property {string} origin // 필수(카카오링크 등록 origin)
 * @property {() => string=} [getAuthorization]
 * @property {string=} [cookiePath=${PATH_CONFIG}/kaling_cookies.json]
 * @property {boolean=true} [searchExact]
 * @property {"ALL"|"FRIENDS"|"CHATROOMS"="ALL"} [searchFrom]
 * @property {"ALL"|"OpenMultiChat"|"MultiChat"|"DirectChat"="ALL"} [searchRoomType]
 */
/**
 * @typedef {object} RequestOption
 * @property {string} url
 * @property {"GET"|"POST"=} method
 * @property {object=} headers
 * @property {object=} params
 * @property {object=} data // x-www-form-urlencoded
 * @property {object=} json // application/json
 * @property {object=} cookies
 * @property {boolean=} followRedirects
 */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "kakaolink.js";
const { Logger } = require("shared/logger");
const { PATH_CONFIG, IRIS_AOT_URL } = require("shared/config");


const Jsoup = Java.type("org.jsoup.Jsoup");
const Method = Java.type("org.jsoup.Connection$Method");
const URLClass = Java.type("java.net.URL");
const Base64Android = Java.type("android.util.Base64");
const StandardCharsets = Java.type("java.nio.charset.StandardCharsets");


const KAKAOTALK_VERSION = "25.2.1";
const ANDROID_SDK_VER = 33;
const ANDROID_WEBVIEW_UA =
    "Mozilla/5.0 (Linux; Android 13; SM-G998B Build/TP1A.220624.014; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/114.0.5735.60 Mobile Safari/537.36";




/* =================================== 클래스 선언 =================================== */


/**
 * @class KakaoLink
 * @description KakaoLink 전송기 (동기/Jsoup)
 */
class KakaoLink {
    /** @param {KakaoLinkOptions} options */
    constructor(options) {
        if (!options || !options.app_key || !options.origin) {
            throw new Error("KakaoLink: app_key와 origin은 필수입니다.");
        }

        this.appKey = options.app_key;
        this.origin = options.origin;
        this.getAuthorization = typeof options.getAuthorization === "function" ?
            options.getAuthorization :
            getAuthorizationFromIris; // 기본: IRIS AOT 사용
        this.cookiePath = options.cookiePath || `${PATH_CONFIG}/kaling_cookies.json`;

        this.defaultSearchExact = options.searchExact !== false;
        this.defaultSearchFrom = options.searchFrom || "ALL";
        this.defaultSearchRoomType = options.searchRoomType || "ALL";

        /** @type {Record<string,string>} */
        this._cookies = {};
        this._uuidC = Security.uuid();
        this._initialized = false;
    }


    /** @description 쿠키 로드 + 세션 확인(+필요 시 로그인) */
    init() {
        this._loadCookies();
        try {
            if (!this._checkAuthorized()) {
                this._login();
            }
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            // 실패해도 send()에서 재시도
        } finally {
            this._initialized = true;
        }
    }


    /**
     * @description KakaoLink 전송
     * @param {string} receiverName 카톡 방 제목 또는 친구 닉네임
     * @param {number|string} templateId 커스텀 템플릿 ID
     * @param {object} templateArgs 템플릿 인자
     * @param {object=} opt {searchExact, searchFrom, searchRoomType}
     * @returns {boolean}
     */
    send(receiverName, templateId, templateArgs, opt) {
        if (!this._initialized) {
            this.init();
        }

        const searchExact = opt && typeof opt.searchExact === "boolean" ? opt.searchExact : this.defaultSearchExact;
        const searchFrom = opt?.searchFrom || this.defaultSearchFrom;
        const searchRoomType = opt?.searchRoomType || this.defaultSearchRoomType;

        // picker/link
        let pickerData;
        try {
            pickerData = this._getPickerData(this.appKey, this._getKa(this.origin), templateId, templateArgs);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            // 1회 재로그인 후 재시도
            try {
                this._login();
                pickerData = this._getPickerData(this.appKey, this._getKa(this.origin), templateId, templateArgs);
            } catch (e2) {
                Logger.e(_SCRIPT_NAME, e2);
                return false;
            }
        }

        // 필드 추출
        let checksum, csrf, shortKey;
        try {
            checksum = pickerData.checksum;
            csrf = pickerData.csrfToken;
            shortKey = pickerData.shortKey;
        } catch (e) {
            Logger.e(_SCRIPT_NAME, new Error("KakaoLink: pickerData 파싱 실패"));
            return false;
        }

        // 수신자 검색
        let receiver;
        try {
            receiver = this._pickerDataSearch(receiverName, pickerData, searchExact, searchFrom, searchRoomType);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return false;
        }

        // picker/send
        try {
            this._pickerSend(this.appKey, shortKey, checksum, csrf, receiver);
            return true;
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return false;
        }
    }




    /* ============================ 핵심 흐름 ============================ */


    /**
     * @description picker/link 요청 및 로그인/2FA 처리
     * @returns {object} pickerData
     */
    _getPickerData(appKey, ka, templateId, templateArgs) {
        const headers = this._getWebHeaders();
        const data = {
            app_key: appKey,
            ka: ka,
            validation_action: "custom",
            validation_params: JSON.stringify({
                link_ver: "4.0",
                template_id: templateId,
                template_args: templateArgs,
            }),
        };

        let res = this._request({
            url: "https://sharer.kakao.com/picker/link",
            method: "POST",
            headers,
            data,
            cookies: this._cookies,
            followRedirects: true,
        });

        // /login으로 리다이렉트 → 로그인
        const finalUrl = res.url;
        const path = new URLClass(finalUrl).getPath();
        if (path.startsWith("/login")) {
            const query = new URLClass(finalUrl).getQuery();
            const params = this._parseQuery(query || "");
            const continueUrl = params.continue;
            this._login();

            res = this._request({
                url: continueUrl,
                method: "GET",
                headers,
                cookies: this._cookies,
                followRedirects: true,
            });
        }

        // 2FA 흐름
        let path2 = new URLClass(res.url).getPath();
        if (path2.startsWith("/talk_tms_auth/service")) {
            Logger.i(_SCRIPT_NAME, "카카오링크 전송: 추가인증 해결 중");
            const continueUrl = this._solveTwoFactorAuth(res.body);
            res = this._request({
                url: continueUrl,
                method: "GET",
                headers,
                cookies: this._cookies,
                followRedirects: true,
            });
            path2 = new URLClass(res.url).getPath();
        }

        const serverDataB64 = this._extractWindowServerData(res.body);
        const decoded = this._base64UrlDecode(serverDataB64);
        const json = JSON.parse(decoded);
        return json.data;
    }
    /** @description picker/send 호출 */
    _pickerSend(appKey, shortKey, checksum, csrf, receiverObj) {
        const payload = {
            app_key: appKey,
            short_key: shortKey,
            checksum: checksum,
            _csrf: csrf,
            receiver: this._base64UrlEncode(JSON.stringify(receiverObj)),
        };

        const res = this._request({
            url: "https://sharer.kakao.com/picker/send",
            method: "POST",
            headers: this._getWebHeaders(),
            data: payload,
            cookies: this._cookies,
        });

        if (res.statusCode === 400) {
            throw new Error("카카오링크 전송 실패(400)");
        }
    }


    /** @description 로그인 수행 (talk_session_info → TGT → e.kakao.com 세션) */
    _login() {
        const authorization = this.getAuthorization && this.getAuthorization();
        if (!authorization) {
            throw new Error("getAuthorization()이 talk_session_info 토큰을 반환해야 합니다");
        }
        if (this._checkAuthorized()) return;

        const tgt = this._getTgtToken(authorization);
        this._submitTgtToken(tgt);

        if (!this._checkAuthorized()) {
            throw new Error("카카오링크 로그인 실패(원인 미상)");
        }
        this._saveCookies();
    }
    /**
     * @description 2FA 처리
     * @param {string} tfaHtml
     * @returns {string} continueUrl
     */
    _solveTwoFactorAuth(tfaHtml) {
        let props;
        try {
            const marker = '<script id="__NEXT_DATA__" type="application/json">';
            const jsonStr = tfaHtml.split(marker)[1].split("</script>")[0].trim();
            props = JSON.parse(jsonStr);

            const context = props.props.pageProps.pageContext.context;
            const commonContext = props.props.pageProps.pageContext.commonContext;

            const token = context.token;
            const continueUrl = context.continueUrl;
            const csrf = commonContext._csrf;

            // confirm token (auth.kakao.com)
            this._confirmToken(token);

            // poll (accounts.kakao.com)
            const res = this._request({
                url: "https://accounts.kakao.com/api/v2/talk_tms_auth/poll_from_service.json",
                method: "POST",
                headers: this._getWebHeaders(),
                json: { _csrf: csrf, token },
                cookies: this._cookies,
            });
            const resJson = JSON.parse(res.body);
            if (resJson.status !== 0) throw new Error(`2FA Poll 실패 status=${resJson.status}`);
            return continueUrl;
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            throw e;
        }
    }
    /** @description 추가인증 토큰 승인 */
    _confirmToken(twoFactorToken) {
        const params = {
            os: "android",
            country_iso: "KR",
            lang: "ko",
            v: KAKAOTALK_VERSION,
            os_version: ANDROID_SDK_VER,
            page: "additional_auth_with_token",
            additional_auth_token: twoFactorToken,
            close_on_completion: "true",
            talk_tms_auth_type: "from_service",
        };
        const res = this._request({
            url: "https://auth.kakao.com/fa/main.html",
            method: "GET",
            params,
            cookies: this._cookies,
        });

        // csrf 및 options 파싱
        let csrf, options;
        try {
            csrf = res.body.split('<meta name="csrf-token" content="')[1].split('"')[0].trim();
            const optStr = res.body.split("var options =")[1].split("new PageBuilder()")[0].trim().replace(/;$/, "").trim();
            options = JSON.parse(optStr);
        } catch (e) {
            throw new Error("2FA confirm_token 파싱 실패");
        }

        const res2 = this._request({
            url: "https://auth.kakao.com/talk_tms_auth/confirm_token.json",
            method: "POST",
            data: {
                client_id: options.client_id,
                lang: "ko",
                os: "android",
                v: KAKAOTALK_VERSION,
                webview_v: "2",
                token: options.additionalAuthToken,
                talk_tms_auth_type: "from_service",
                authenticity_token: csrf,
            },
            cookies: this._cookies,
        });
        const j = JSON.parse(res2.body);
        if (j.status !== 0) throw new Error(`2FA confirm_token 실패 status=${j.status}`);
    }
    /** @description 현재 세션 유효성 검사 */
    _checkAuthorized() {
        try {
            const res = this._request({
                url: "https://e.kakao.com/api/v1/users/me",
                method: "GET",
                headers: Object.assign({}, this._getWebHeaders(), { referer: "https://e.kakao.com/" }),
                cookies: this._cookies,
            });
            const j = JSON.parse(res.body);
            const result = j.result || {};
            return result.status === "VALID";
        } catch (_) {
            return false;
        }
    }
    /**
     * @description TGT 토큰 발급
     * @returns {string} tgt token
     */
    _getTgtToken(authorizationToken) {
        const res = this._request({
            url: "https://api-account.kakao.com/v1/auth/tgt",
            method: "POST",
            headers: this._getAppHeaders(authorizationToken),
            data: { key_type: "talk_session_info", key: authorizationToken, referer: "talk" },
            cookies: this._cookies,
        });
        const j = JSON.parse(res.body);
        if (j.code !== 0) throw new Error(`tgt 토큰 발급 오류: ${res.body}`);
        return j.token;
    }
    /** @description TGT 제출로 e.kakao.com 세션 수립 */
    _submitTgtToken(tgtToken) {
        const res = this._request({
            url: "https://e.kakao.com",
            method: "GET",
            headers: Object.assign({}, this._getWebHeaders(), { "ka-tgt": tgtToken }),
            cookies: this._cookies,
        });
        if (!(res.statusCode >= 200 && res.statusCode < 400)) {
            throw new Error("TGT 제출 실패");
        }
    }




    /* ============================ 유틸/헬퍼 ============================ */


    /** @description 수신자 검색 */
    _pickerDataSearch(receiverName, pickerData, searchExact, searchFrom, searchRoomType) {
        const list = [];
        if (searchFrom === "ALL" || searchFrom === "CHATROOMS") {
            if (pickerData.chats) list.push.apply(list, pickerData.chats);
        }
        if (searchFrom === "ALL" || searchFrom === "FRIENDS") {
            if (pickerData.friends) list.push.apply(list, pickerData.friends);
        }

        for (let receiver of list) {
            const currentChatType = receiver.chat_room_type; // 챗방일 때 존재
            const currentTitle = receiver.title || receiver.profile_nickname || "";

            if (currentChatType) {
                if (searchRoomType !== "ALL" && searchRoomType !== currentChatType) continue;
            }
            if (searchExact) {
                if (currentTitle === receiverName) return receiver;
            } else {
                if (currentTitle.includes(receiverName)) return receiver;
            }
        }
        throw new Error("수신자를 찾을 수 없습니다");
    }


    /** @description 서버 window.serverData Base64 문자열 추출 */
    _extractWindowServerData(html) {
        const s = String(html);
        const head = 'window.serverData = "';
        const i = s.indexOf(head);
        if (i < 0) throw new Error("serverData 스크립트를 찾을 수 없습니다");
        const tail = s.indexOf('"', i + head.length);
        if (tail < 0) throw new Error("serverData 종료를 찾을 수 없습니다");
        let b64 = s.substring(i + head.length, tail).trim();
        while (b64.length % 4 !== 0) b64 += "="; // 패딩 보정
        return b64;
    }
    _getKa(origin) {
        const encoded = encodeURIComponent(origin);
        return `sdk/1.43.5 os/javascript sdk_type/javascript lang/ko-KR device/Linux armv7l origin/${encoded}`;
    }
    _getAppHeaders(token) {
        return {
            "A": `android/${KAKAOTALK_VERSION}/ko`,
            "C": this._uuidC,
            "User-Agent": `KT/${KAKAOTALK_VERSION} An/13 ko`,
            "Authorization": token, // talk_session_info 토큰
        };
    }
    _getWebHeaders() {
        return {
            "User-Agent": `${ANDROID_WEBVIEW_UA} KAKAOTALK/${KAKAOTALK_VERSION} (INAPP)`,
            "X-Requested-With": "com.kakao.talk",
        };
    }


    _base64UrlEncode(str) {
        const bytes = new java.lang.String(str).getBytes(StandardCharsets.UTF_8);
        const flags = Base64Android.NO_WRAP | Base64Android.URL_SAFE | Base64Android.NO_PADDING;
        return Base64Android.encodeToString(bytes, flags);
    }
    _base64UrlDecode(b64url) {
        const flags = Base64Android.NO_WRAP | Base64Android.URL_SAFE;
        const decoded = Base64Android.decode(b64url, flags);
        return new java.lang.String(decoded, StandardCharsets.UTF_8);
    }


    _parseQuery(qs) {
        const s = String(qs || "");
        const out = {};
        if (!s) return out;
        const arr = s.split("&");

        for (let i = 0; i < arr.length; i++) {
            const kv = arr[i];
            if (!kv) continue;
            const idx = kv.indexOf("=");
            if (idx < 0) out[decodeURIComponent(kv)] = "";
            else {
                const k = kv.substring(0, idx);
                const v = kv.substring(idx + 1);
                out[decodeURIComponent(k)] = decodeURIComponent(v);
            }
        }
        return out;
    }


    _mergeCookies(newCookies) {
        if (!newCookies) return;
        for (let k in newCookies) this._cookies[k] = newCookies[k];
    }
    _loadCookies() {
        try {
            const obj = FileStream.readJson(this.cookiePath);
            this._cookies = obj || {};
        } catch (e) {
            this._cookies = {};
        }
    }
    _saveCookies() {
        try {
            FileStream.writeJson(this.cookiePath, this._cookies);
        } catch (_) { }
    }


    /**
     * @description Jsoup 동기 요청 헬퍼
     * @param {RequestOption} opt
     */
    _request(opt) {
        const method = (opt.method || "GET").toUpperCase();
        let url = opt.url;

        if (opt.params) {
            const qs = [];
            for (let k in opt.params) {
                qs.push(`${encodeURIComponent(k)}=${encodeURIComponent(String(opt.params[k]))}`);
            }
            if (qs.length) url += (url.includes("?") ? "&" : "?") + qs.join("&");
        }

        const conn = Jsoup.connect(url)
            .ignoreContentType(true)
            .followRedirects(opt.followRedirects !== false);

        conn.method(method === "POST" ? Method.POST : Method.GET);

        if (opt.headers) {
            for (let k in opt.headers) conn.header(k, opt.headers[k]);
        }
        if (opt.cookies) conn.cookies(opt.cookies);

        if (opt.json) {
            conn.header("Content-Type", "application/json; charset=UTF-8");
            conn.requestBody(JSON.stringify(opt.json));
        } else if (opt.data) {
            for (let k in opt.data) conn.data(k, String(opt.data[k]));
        }

        const res = conn.execute();
        const ret = {
            statusCode: res.statusCode(),
            url: res.url().toString(),
            body: res.body(),
            headers: res.headers(),
            cookies: res.cookies(),
        };
        this._mergeCookies(ret.cookies);
        return ret;
    }
}




/* =================================== 헬퍼 =================================== */


/**
 * @description talk_session_info 동기 획득
 * @returns {string} access_token-d_id
 */
function getAuthorizationFromIris() {
    try {
        const body = Jsoup.connect(IRIS_AOT_URL)
            .ignoreContentType(true)
            .execute()
            .body();

        const j = JSON.parse(body);
        const aot = j?.aot;
        if (!aot) throw new Error("IRIS AOT: aot 필드 없음");

        const at = aot.access_token;
        const did = aot.d_id || aot.did || aot.device_id;
        if (!at || !did) {
            throw new Error(`IRIS AOT: access_token(${!!at}), d_id(${!!did}) 누락`);
        }

        return `${at}-${did}`;
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
        return "";
    }
}


/**
 * @description KakaoLink 생성 헬퍼
 * @param {KakaoLinkOptions} options
 */
function create(options) {
    return new KakaoLink(options);
}


module.exports = { KakaoLink, create, getAuthorizationFromIris };