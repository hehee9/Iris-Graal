/**
 * @file node_modules/adapters/kakao/parser.js
 * @description 메시지 raw 데이터 파싱
 * - 4,000자 이상의 메시지 본문, 답장된 메시지의 원본 등은 HTTP 통신 필요
 */


/**
 * @typedef {object} RawJson
 * @property {string} _id 뭔지 모르겠음, 정수형 문자열
 * @property {string} id 메시지 고유의 id, 정수형 문자열
 * @property {string} type 메시지 타입, 정수형 문자열
 * @property {string} chat_id 채팅방 아이디(channelId), 정수형 문자열
 * @property {string} user_id 유저 고유 id, 정수형 문자열
 * @property {string} message 메시지 내용, feed가 아니라면 msg와 같음
 * @property {object} attachment 첨부 데이터 정보. 파일 뿐만 아닌 멘션, 답장 등의 정보 포함
 * @property {string} created_at 메시지 수신 시각, 정수형 문자열
 * @property {string} deleted_at 메시지 삭제 시각, 정수형 문자열
 * @property {string} client_message_id 기기 내 메시지 id, 정수형 문자열
 * @property {string} prev_id 해당 채팅방 내 직전 메시지 id, 정수형 문자열
 * @property {string} referer 리퍼러, 정수형 문자열
 * @property {null?} supplement 뭔지 모르겠음
 * @property {object} v 메시지 수정 횟수, 암호화 여부 등 부가 정보
 */
/**
 * @typedef {object} RawData
 * @property {string} msg 메시지 내용
 * @property {string} room 채팅방 이름
 * @property {string} sender 보낸 사람 이름
 * @property {RawJson} json 추가 데이터 객체
 */

/** @typedef {import("shared/types").Author} Author */
/** @typedef {import("shared/types").Room} Room */
/** @typedef {import("shared/types").Attachment} Attachment */
/** @typedef {import("shared/types").Mention} Mention */
/** @typedef {import("shared/types").Reply} Reply */
/** @typedef {import("shared/types").Message} Message */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "parser.js";
const { Logger } = require("shared/logger");
const { getRoomInfo } = require("infra/roomRegistry");
const { isBanned } = require("shared/utils");




/* =================================== 유틸/헬퍼 =================================== */


/**
 * @description Author 파싱
 * @param {RawData} raw 
 * @returns {Author}
 */
function _parseAuthor(raw) {
    const author = {};
    author.name = raw.sender;
    author.userId = raw?.json?.user_id;
    author.isBanned = isBanned(raw?.json?.user_id);
    return author;
}
/**
 * @description Room 파싱
 * @param {RawData} raw 
 * @returns {Room}
 */
function _parseRoom(raw) {
    const channelId = raw.json.chat_id;
    const name = raw.room;
    const cache = getRoomInfo(channelId, name);
    return cache;
}


/** @description 파일명에서 확장자 추출 */
function _getExtension(fileName) {
    let ext;
    const lastDotIndex = fileName.lastIndexOf('.');

    if (lastDotIndex < 1) ext = null;
    else ext = fileName.slice(lastDotIndex + 1).toLowerCase();

    return ext;
}
/** @description 확장자에서 파일 타입 추출 */
function _getFileType(ext) {
    // 카카오톡에서 지원하는 파일 타입, 완성은 todo
    const fileTypes = {
        image: [
            "png",
            "jpg", "jpeg",
            "gif",
            "bmp",
            "tif", "tiff", "tga",
            "psd", "ai",
            "webp"
        ],
        video: [],
        audio: [],
        // ...
    };

    for (const [type, exts] of Object.entries(fileTypes)) {
        if (exts.includes(ext)) return type;
    }
    return ext;
}
/** @description 카카오링크에서 이미지 url 추출 */
function _findTHUValues(obj) {
    const results = [];
    
    function _traverse(current) {
        if (current === null || current === undefined) {
            return;
        }
        
        // 배열인 경우
        if (Array.isArray(current)) {
            for (let c of current) _traverse(c);
            return;
        }
        
        // 객체인 경우
        if (typeof current === "object") {
            for (let key in current) {
                if (current.hasOwnProperty(key)) {
                    // THU 키를 찾으면 값을 결과에 추가
                    if (key === "THU") results.push(current[key]);
                    _traverse(current[key]);
                }
            }
        }
    }
    
    _traverse(obj);
    return results;
}
/**
 * @description Attachment 파싱
 * @param {RawData} raw 
 * @returns {Attachment[]}
 */
function _parseAttachment(raw) {
    const attachmentList = [];
    const { type, attachment } = raw.json;
    let file = {};

    switch(type) {
    // 단일 이미지
    case "2":
        file.type = "image";
        file.mime = attachment.mt;
        file.url = attachment.url;
        file.size = attachment.s;
        file.name = String(Date.now());
        attachmentList.push(file);
        break;
    
    // 동영상
    case "3":
        file.type = "video";
        file.mime = attachment.mt;
        file.url = attachment.url;
        file.size = attachment.s;
        file.name = String(Date.now());
        attachmentList.push(file);
        break;

    // todo: 오디오 (5)

    // 기타 파일. 사진/영상 포함
    case "18":
        file.type = _getFileType(_getExtension(attachment.name)); // todo: 구조 예쁘게 변경. 잘 하면 mime 처리도 될 듯?
        file.mime = ""; // todo: mimetype 확인
        file.url = attachment.url;
        file.size = attachment.s;
        file.name = attachment.name;
        attachmentList.push(file);
        break;
    
    // 사진 여러 장
    case "27":
        for (let i = 0; i < attachment.imageUrls.length; i++) {
            const result = {};
            result.type = "image";
            result.name = `${String(Date.now())}_${i}`;
            result.mime = attachment.mtl[i];
            result.url = attachment.imageUrls[i];
            result.size = attachment.sl[i];
            attachmentList.push(result);
        }
        break;
    
    // 카카오링크
    // 구조가 제각각이므로 이미지 url만 추출
    case "71":
        const urls = _findTHUValues(attachment);
        if (urls.length === 0) break;

        urls.forEach(url => {
            const result = {};
            result.type = "image";
            result.name = String(Date.now());
            result.mime = ""; // todo: mimetype 확인
            result.size = 0;
            result.url = url;
            attachmentList.push(result);
        })
        break;
    }

    return attachmentList;
}


/**
 * @description Mention 파싱
 * @param {RawData} raw
 * @returns {Mention[]}
 */
function _parseMention(raw) {
    const attachment = raw.json.attachment;
    // if (attachment.all_mention) return; // 일단 전체멘션은 별도 처리 X

    if (!attachment?.mentions) return [];
    const mentions = attachment.mentions;
    const result = [];
    mentions.forEach(mention => {
        const srcUserId = mention.user_id;
        const { at, len } = mention;
        result.push({ srcUserId, at, len });
    });

    return result;
}
/**
 * @description Reply 파싱
 * @param {RawData} raw
 * @returns {Reply|null}
 */
function _parseReply(raw) {
    const { type, attachment } = raw.json;
    if (type !== "26") return null;

    const srcId = attachment.src_logId;
    const srcUserId = attachment.src_userId;
    const srcType = attachment.src_type;
    return { srcId, srcUserId, srcType };
}




/* =================================== 메인 로직 =================================== */


/**
 * @description 메시지 파싱
 * @param {RawData} raw 
 * @returns {Message}
 */
function parseMessage(raw) {
    const json = raw.json;

    const author = _parseAuthor(raw);
    const room = _parseRoom(raw);
    const content = String(raw.msg); // 4000자를 넘으면 전체를 불러와서 덮어써야 함
    const id = json.id;
    const type = json.type;
    const isMine = json.v?.isMine;
    const reply = _parseReply(raw);
    const mention = _parseMention(raw);
    const attachment = _parseAttachment(raw);

    return {
        author, room, content,
        id, type, isMine,
        reply, mention, attachment
    };
}


module.exports = { parseMessage };