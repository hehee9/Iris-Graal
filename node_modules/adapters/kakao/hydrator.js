/**
 * @file node_modules/adapters/kakao/hydrator.js
 * @description 로컬/카카오 서버 DB 질의
 * @todo http 요청 시의 헤더 등은 utils, config로 이동
 */


/** @typedef {import("adapters/kakao/parser").RawData} RawData */
/** @typedef {import("adapters/kakao/parser").RawJson} RawJson */




/* =================================== 상수/전역 =================================== */


const _SCRIPT_NAME = "hydrator.js";
const { Logger } = require("shared/logger");
const { KAKAO_SERVER_URL, IRIS_QUERY_TIMEOUT, REMOVE_ZWS } = require("shared/config");
const { parseMessage } = require("adapters/kakao/parser");
const { executeQuery } = require("shared/utils");


const Jsoup = Java.type("org.jsoup.Jsoup");




/* =================================== 유틸/헬퍼 =================================== */


/**
  * @description 문자열 JSON일 수 있는 필드를 객체로 안전 파싱
  * @param {any} x
  * @returns {object} 파싱 성공 시 객체, 실패/부재 시 {}
  */
function _parseMaybeJsonObject(x) {
    if (!x) return {};
    if (typeof x === "object") return x;
    if (typeof x === "string") {
        try {
            const processed = x.replace(/([:,\[])\s*(-?\d{13,})\b/g, '$1"$2"');
            return JSON.parse(processed);
        } catch (e) {
            Logger.e(_SCRIPT_NAME, e);
            return {};
        }
    }
    return {};
}




/* =================================== 메인 로직 =================================== */


/**
 * @description DB 한 행(row)을 RawData로 변환
 * @param {object} row DB 결과의 단일 행
 * @param {{roomName?: string, senderName?: string}} [opts]
 * @returns {RawData}
 */
function adaptDbRowToRawData(row, opts) {
    const vObj = _parseMaybeJsonObject(row.v);
    const attObj = _parseMaybeJsonObject(row.attachment); // null/string → {}
  
    /** @type {RawJson} */
    const json = {
        _id: row._id,
        id: row.id,
        type: row.type,
        chat_id: String(row.chat_id),
        user_id: String(row.user_id),
        message: row.message,
        attachment: attObj,
        created_at: String(row.created_at),
        deleted_at: String(row.deleted_at),
        client_message_id: String(row.client_message_id),
        prev_id: String(row.prev_id),
        referer: row.referer,
        supplement: row.supplement,
        v: vObj
    };
  
    /** @type {RawData} */
    const rawData = {
        msg: row.message || "",
        room: (opts && typeof opts.roomName === "string") ? opts.roomName : "",
        sender: (opts && typeof opts.senderName === "string") ? opts.senderName : "",
        json
    };
  
    return rawData;
}
/**
 * @description DB 응답({ data: Row[] })을 RawData[]로 변환
 * @param {{data: object[]}} resp
 * @param {{roomName?: string, senderName?: string}} [opts]
 * @returns {RawData[]}
 */
function adaptDbResponseToRawDataList(resp, opts) {
    const arr = (resp && Array.isArray(resp.data)) ? resp.data : [];
    const out = [];
    for (let row of arr) {
        out.push(adaptDbRowToRawData(row, opts));
    }
    return out;
}



/* ================== 채팅(메시지) 관련 ================== */


/**
 * @description 4000자 넘는 텍스트 전문 가져오기
 * @param {RawData} raw
 * @returns {string} 메시지 전문
 */
function ensureFullContent(raw) {
    const { type, attachment } = raw.json;
    if (type !== "1") return raw.msg;

    const path = attachment.path;
    if (!path) return raw.msg;

    try {
        const url = KAKAO_SERVER_URL + path;
        const response = Jsoup.connect(url)
            .ignoreContentType(true)
            .ignoreHttpErrors(true)
            .maxBodySize(0)
            .timeout(IRIS_QUERY_TIMEOUT)
            .execute().body();
        
        return String(response);
    } catch (e) {
        Logger.e(_SCRIPT_NAME, e);
        return raw.msg;
    }
}
/**
 * @description 답장 메시지의 원본 추출
 * - 재귀 호출은 하지 않음
 * @param {string} srcId 
 * @returns {import("shared/types").Message|null}
 */
function resolveReplyOriginal(srcId) {
    const query = `SELECT * FROM chat_logs WHERE id = ${srcId}`;
    const dbRaw = executeQuery(query);
    if (!dbRaw) return null;

    // 누락된 데이터 보정
    const raw = adaptDbRowToRawData(dbRaw);
    raw.msg = ensureFullContent(raw);
    if (REMOVE_ZWS) raw.msg = raw.msg.replace(/\u200b|\u200d/g, "");
    raw.json.message = raw.msg;

    raw.sender = getUserNameWithId(raw.json.user_id);
    // raw.room = // 필요 시 추가

    const parsed = parseMessage(raw);
    return parsed;
}



/* ================== 유저 관련 ================== */


/**
 * @description userId로 닉네임 조회
 * @param {string|bigint} userId 
 * @returns {string|null}
 */
function getUserNameWithId(userId) {
    const query = `
WITH info AS (SELECT ${userId} AS user_id)
SELECT COALESCE(open_chat_member.nickname, friends.name) AS name,
COALESCE(open_chat_member.enc, friends.enc) AS enc FROM info
LEFT JOIN db2.open_chat_member
ON open_chat_member.user_id = info.user_id
LEFT JOIN db2.friends
ON friends.id = info.user_id;`;

    const result = executeQuery(query);
    return result?.name || null;
}
/**
 * @description 프로필 사진 원본 url 조회
 * @param {string|bigint} userId 
 * @param {string|bigint} channelId 
 * @returns {string|null}
 */
function getProfileImageUrl(userId, channelId) {
    const isOpenChat = BigInt(channelId) > 10_000_000_000_000_000;
    const query = isOpenChat ? 
`SELECT
    COALESCE(original_profile_image_url, full_profile_image_url, profile_image_url) AS profile_image_url, enc
    FROM db2.open_chat_member
    WHERE user_id = ${userId};` :
`SELECT
    COALESCE(original_profile_image_url, full_profile_image_url, profile_image_url) AS profile_image_url, enc
    FROM db2.friends
    WHERE id = ${userId};`;

    const result = executeQuery(query);
    return result?.profile_image_url || null;
}


/**
 * @description 알림 기반 유저 식별자 호환
 * @param {string|bigint} userId 
 * @param {string|bigint} channelId 
 * @returns {string}
 */
function getAuthorHash(userId, channelId) {
    return Security.sha256(`person_${channelId}:${userId}`);
}



/* ================== 채팅방 관련 ================== */


/**
 * @description 채팅방 내 현재 존재하는 모든 인원의 id 조회
 * @param {string|bigint} channelId 
 * @returns {string[]}
 */
function getAllMemberIds(channelId) {
    const query = `SELECT id, active_member_ids FROM chat_rooms WHERE id = ${channelId}`;

    const result = executeQuery(query);
    const rawMembers = result.data[0]?.active_member_ids || "";
    const members = rawMembers.slice(1, rawMembers.length - 1).split(",");
    return members || [];
}
/**
 * @description 채팅방 내 멤버 수 확인
 * @param {string|bigint} channelId 
 * @returns 
 */
function getMemberCount(channelId) {
    const query = `SELECT active_members_count FROM chat_rooms WHERE id = ${channelId}`;
    const result = executeQuery(query);
    return result?.active_members_count || 0;
}


/**
 * @description 채팅방 타입 조회
 * @param {string|bigint} channelId 
 * @returns {object|null}
 */
function getRoomType(channelId) {
    const query = `SELECT type FROM chat_rooms WHERE id = ${channelId}`;
    const result = executeQuery(query);
    const type = result?.type;
    if (!type) return null;

    let obj;
    switch (type) {
    case "OM": obj = { isOpenChat: true, isGroupChat: true }; break;
    case "OD": obj = { isOpenChat: true, isGroupChat: false }; break;
    case "MultiChat": obj = { isOpenChat: false, isGroupChat: true }; break;
    case "DirectChat": case "SDirectChat": obj = { isOpenChat: false, isGroupChat: false }; break;
    }

    return obj;
}


module.exports = {
    adaptDbRowToRawData, adaptDbResponseToRawDataList,

    ensureFullContent, resolveReplyOriginal,
    getUserNameWithId, getProfileImageUrl, getAuthorHash,
    getAllMemberIds, getMemberCount, getRoomType
};